import { EventEmitter } from 'events';

import * as wire from './wire';

/**
 * Message - a high-level message object, which exposes stateful methods
 * for responding to nsqd (FIN, REQ, TOUCH, etc.) as well as metadata
 * such as attempts and timestamp.
 * @type {Message}
 */
class Message extends EventEmitter {
  // Event types
  static BACKOFF = 'backoff';
  static RESPOND = 'respond';

  // Response types
  static FINISH = 0;
  static REQUEUE = 1;
  static TOUCH = 2;

  /**
   * Instantiates a new instance of a Message.
   * @constructor
   * @param  {String} id
   * @param  {String|Number} timestamp
   * @param  {Number} attempts
   * @param  {String} body
   * @param  {Number} requeueDelay
   * @param  {Number} msgTimeout
   * @param  {Number} maxMsgTimeout
   */
  constructor(
    id,
    timestamp,
    attempts,
    body,
    requeueDelay,
    msgTimeout,
    maxMsgTimeout
  ) {
    super(...arguments); // eslint-disable-line prefer-rest-params
    this.id = id;
    this.timestamp = timestamp;
    this.attempts = attempts;
    this.body = body;
    this.requeueDelay = requeueDelay;
    this.msgTimeout = msgTimeout;
    this.maxMsgTimeout = maxMsgTimeout;
    this.hasResponded = false;
    this.receivedOn = Date.now();
    this.lastTouched = this.receivedOn;
    this.touchCount = 0;
    this.trackTimeoutId = null;

    // Keep track of when this message actually times out.
    this.timedOut = false;
    this.trackTimeout();
  }

  /**
   * track whether or not a message has timed out.
   */
  trackTimeout() {
    if (this.hasResponded) return;

    const soft = this.timeUntilTimeout();
    const hard = this.timeUntilTimeout(true);

    // Both values have to be not null otherwise we've timedout.
    this.timedOut = !soft || !hard;
    if (!this.timedOut) {
      clearTimeout(this.trackTimeoutId);
      this.trackTimeoutId = setTimeout(
        () => this.trackTimeout(),
        Math.min(soft, hard)
      ).unref();
    }
  }

  /**
   * Safely parse the body into JSON.
   *
   * @return {Object}
   */
  json() {
    if (this.parsed == null) {
      try {
        this.parsed = JSON.parse(this.body);
      } catch (err) {
        throw new Error('Invalid JSON in Message');
      }
    }

    return this.parsed;
  }

  /**
   * Returns in milliseconds the time until this message expires. Returns
   * null if that time has already ellapsed. There are two different timeouts
   * for a message. There are the soft timeouts that can be extended by touching
   * the message. There is the hard timeout that cannot be exceeded without
   * reconfiguring the nsqd.
   *
   * @param  {Boolean} [hard=false]
   * @return {Number|null}
   */
  timeUntilTimeout(hard = false) {
    if (this.hasResponded) return null;

    let delta;
    if (hard) {
      delta = this.receivedOn + this.maxMsgTimeout - Date.now();
    } else {
      delta = this.lastTouched + this.msgTimeout - Date.now();
    }

    if (delta > 0) {
      return delta;
    }

    return null;
  }

  /**
   * Respond with a `FINISH` event.
   */
  finish() {
    this.respond(Message.FINISH, wire.finish(this.id));
  }

  /**
   * Requeue the message with the specified amount of delay. If backoff is
   * specifed, then the subscribed Readers will backoff.
   *
   * @param  {Number}  [delay=this.requeueDelay]
   * @param  {Boolean} [backoff=true]            [description]
   */
  requeue(delay = this.requeueDelay, backoff = true) {
    this.respond(Message.REQUEUE, wire.requeue(this.id, delay));
    if (backoff) {
      this.emit(Message.BACKOFF);
    }
  }

  /**
   * Emit a `TOUCH` command. `TOUCH` command can be used to reset the timer
   * on the nsqd side. This can be done repeatedly until the message
   * is either FIN or REQ, up to the sending nsqdâ€™s configured max_msg_timeout.
   */
  touch() {
    this.touchCount += 1;
    this.lastTouched = Date.now();
    this.respond(Message.TOUCH, wire.touch(this.id));
  }

  /**
   * Emit a `RESPOND` event.
   *
   * @param  {String} responseType
   * @param  {String} wireData
   * @return {undefined}
   */
  respond(responseType, wireData) {
    // TODO: Add a debug/warn when we moved to debug.js
    if (this.hasResponded) return;

    process.nextTick(() => {
      if (responseType !== Message.TOUCH) {
        this.hasResponded = true;
        clearTimeout(this.trackTimeoutId);
        this.trackTimeoutId = null;
      } else {
        this.lastTouched = Date.now();
      }

      this.emit(Message.RESPOND, responseType, wireData);
    });
  }
}

export default Message;
